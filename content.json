[{"title":"正则表达式鸟瞰","date":"2017-07-16T16:30:32.308Z","path":"2017/07/17/正则表达式鸟瞰/","text":"在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。 摘自 deerchao 的 正则表达式30分钟入门教程 入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.\\bLucy\\b。这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.*\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。 元字符 现在你已经知道几个很有用的元字符了，如\\b,.,，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。下面来看看更多的例子：\\ba\\w\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w)，最后是单词结束处(\\b)。\\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\\b\\w{6}\\b 匹配刚好6个字符的单词。 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\。当然，要查找\\本身，你也得用\\.例如：deerchao.net匹配deerchao.net，C:\\Windows匹配C:\\Windows。 重复 你已经看过了前面的,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如,{5,12}等)： 代码 说明 * 重复零次或更多次 + 重复一次或更多次 ？ 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 下面是一些使用重复的例子：Windows\\d+匹配Windows后面跟1个或更多数字^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。 分支条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。(0\\d{2})[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义： 代码 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：\\S+匹配不包含空白符的字符串。]+&gt;匹配用尖括号括起来的以a开头的字符串。 后向引用 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例： \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些： 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 捕获 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) 捕获 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 零宽断言 (?&lt;=exp) 匹配exp后面的位置 零宽断言 (?!exp) 匹配后面跟的不是exp的位置 零宽断言 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？ 零宽断言接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})+\\b，用它对1234567890进行查找时结果是234567890。下面这个例子同时使用了这两种断言：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\\b\\wq[^u]\\w\\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w\\b将会匹配下一个单词，于是\\b\\wq[^u]\\w\\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\\b\\wq(?!u)\\w\\b。零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\\/\\1&gt;)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。 注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|250-5|[01]?\\d\\d?(?#0-199)。要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： 1234567(?&lt;= # 断言要匹配的文本的前缀&lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\\/\\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签) # 后缀结束 贪婪与懒惰 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。","tags":[{"name":"library","slug":"library","permalink":"http://zhg.com/tags/library/"}]},{"title":"sass和stylus对比介绍","date":"2017-07-15T20:54:56.260Z","path":"2017/07/16/sass和stylus对比介绍/","text":"在众多的css预处理器语言中，sass和stylus算是十分优秀的两个。 转载自 pavoooo 的 https://segmentfault.com/a/1190000008013566 参考资料 sass中文官网 SASS用法指南 stylus官网 stylus中文 1.安装sass是基于Ruby语言写的，假设你已经安装了Ruby，在命令行运行: 1gem install sass stylus是nodejs的一个模块，假设你已经安装了nodejs，在命令行运行: 1npm install stylus 2.使用sass就是普通的文本文件，根据后缀名的不同(.sass或.scss)书写格式不同. stylus也是普通的文本文件,stylus文件的后缀名一般是.styl。 两者都提供了基本的命令行语法，所以我们可以直接在命令行中使用命令对sass文件或者style文件进行编译。但相对来说stylus的命令行操作更为强大。 如果要将显示结果保存成文件，sass需要在后面再跟一个.css文件名。 1sass test.scss test.css stylus则直接如下，就生成了一个同名的文件。 1stylus test.styl 除此，stylus的命令行工具还提供了一些其它基本的功能: repl环境 在命令行中直接输入stylus就得到了stylus的repl环境，我们可以直接在命令行中书写stylus的内容: 12body color: red 然后按下ctrl+d键，就直接在命令行中输出编译结果。 3.变量sass允许使用变量，所有的变量以$开头。 1234$blue: #1875e7;div &#123; color: $blue &#125; stylus也允许使用变量，变量名的$是可选的，变量值可以是表达式。 123color = blue 或者 $color = bluediv color: color 如果变量需要镶嵌在字符串中，sass需要写在#{}之中。 1234$side: left;.rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125; stylus则直接使用{} 123side = 5px.roundeed border-&#123;side&#125;-radius: 5px 4.计算功能sass允许在代码中使用算式: 12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; stylus同样也支持在代码中使用算式: 1234body margin: (14px/2) top: 50px + 100px right: var * 10% %也是stylus的一个运算符，所以上面的right实际的计算结果是var 10 % === var 10。 stylus的运算十分强大，给予了css的编程能力。张鑫旭大神翻译的stylus文档 除此，stylus有一个更为强大的地方就是，stylus可以直接进行属性查找，使用@符号查找属性。如一个常见的垂直居中的例子: 12345678div width: 100px height: 100px position: absolute top: 50% left: 50% margin-left: -(@width / 2) margin-top: -(@width / 2) 5.嵌套sass允许选择器嵌套，比如下面的css代码: 12345div &#123; h1&#123; color: red &#125;&#125; stylus同样支持选择器嵌套，上面的代码可以写成: 123div h1 color: red 在嵌套的代码块内，两者都可以通过&amp;引用父元素。比如a:hover伪类，可以写成: 123456789 a&#123; &amp;:hover &#123; color: #ffb3ff &#125;&#125;***a &amp;:hover color: #ffb3ff 6.继承sass允许一个选择器，继承(@extend)另一个选择器。比如，现在class1： 1234567.class1 &#123; border: 1px solid #ddd &#125;.class2 &#123; @extend .class1 font-size: 120%&#125; stylus的继承方式和sass基本一致，但有一些稍微的不同。 stylus实现继承: 1234567.class1 border: 1px solid #dddclass2继承class1.class2 @extend .class1 font-size: 120% 两者的区别主要在于–sass不允许@extend嵌套选择器:如下面的样式: 123456789101112div h1 color: red在sass中，如果按照下面这样写就会直接编译错误。 .div2 &#123; @extend div h1 &#125;而在stylus中却可以成功编译，因为stylus中，只要选择器匹配，继承就会生效。.div2 @extend div h1 7.Mixinsass使用@mixin命令，定义一个代码块。 1234@mixin left &#123; float: left; margin-left: 10px; &#125; 使用@include命令，调用这个mixin。 123div&#123; @include left; &#125; stylus中的mixin和其函数的书写形式是一样的。但是应用却很大的不同！书写形式如下: 123left() float: left margin-left: 10px 调用的时候直接通过名称调用: 12div left() sass中的mixin可以传递参数，同时还可以为参数提供默认值。如下面是一个mixin实例，用来生成浏览器的前缀。 12345@mixin rounded($vert, $horz, $radius: 10px)&#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;-#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; &#125; 使用的时候可以像下面这样调用: 1#navbar li &#123;@include rounded(top, left)&#125; stylus也允许给mixin提供参数并提供默认值，所以上面的形式在stylus中的书写是这样的： 1234rounded(vert, horz, radius = 10px) border-&#123;vert&#125;-&#123;horz&#125;-radius: radius -moz-border-radius-&#123;vert&#125;&#123;horz&#125;: radius; -webkit-border-&#123;vert&#125;-&#123;horz&#125;-radius: radius; 按照如下方式使用： 123#navbar li rounded(top, left) 除此，stylus的mixin还提供了一些其他的很强大的功能: 1、arguments变量这个变量更合理的解释是定义的mixin当作函数调用的时候(二者的定义是相同的)存在的局部变量。我们可以这样使用: 12radius() border-radius: arguments 调用： 12div radius(5px 10px/5px 5px) 2、父级引用我们同样可以在stylus的mixin中使用父级引用操作符:&amp; 1234hover() a &amp;:hover color: red 8.颜色函数sass提供了一些内置的颜色函数，以便生成系列颜色。 1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 在stylus中也提供了内置的颜色函数，使用也十分简单。如： 12red(#c00) //返回颜色的r色值image-size(path) //获取指定path图片的width和height 更多的方法，请参考stylus内置方法 9.插入文件sass的@import命令，用于插入外部的文件。 1@import \"path/filename.scss\"; 如果是css文件，则等同于css的import命令。 1@import \"foo.css\"; stylus也提供了@import命令用于插入外部的文件，和sass的用法基本一致，如下: 12@import \"reset.css\"@import \"reset.styl\" 除了@import命令，stylus也提供了其他的几个比较实用的命令。 1、@media工作原理和css中常规的媒体查询一样，实用stylus的书写形式: 1234@media print #header #footer display: none 2、@font-face用法和常规css用法一致，同样使用stylus的格式书写: 1234@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf) 3、@keyframes写法和常规的css一致，但会默认编译成@-webkit-keyframes，即: 12345@keyframes 0% color: red 100% color: green 会变编译成: 12345678@-webkit-keyframes&#123; 0%&#123; color: red &#125; 100%&#123; color: green &#125; &#125; 我们可以全局指定vendors变量进行标准解析: 123456vendors = official@keyframes 0% color: red 100% color: green 会编译成: 12345678@keyframes&#123; 0%&#123; color: red &#125; 100%&#123; color: green &#125; &#125; 10.条件语句sass中使用@if可以用来做判断，如下： 1234p &#123; @if 1 + 1 == 2 &#123;border: 1px solid;&#125; @if 5 &lt; 3 &#123;border: 2px dotted;&#125; &#125; stylus中可以直接使用if关键字，级上面的写法在stylus中的书写方式如下： 12345p if 1 + 1 == 2 border: 1px solid if 5 &lt; 3 border: 2px dotted sass中也提供了@else关键字和@if搭配: 12345@if lightness($color) &gt; 30% &#123; background-color: #000;&#125; @else &#123; background-color: #fff;&#125; stylus则可以直接在if语句后面跟上else语句: 12345if red(color) &gt; 50 &#123; &#125; else &#123; &#125; 除此，stylus也提供了unless关键字，同时支持条件后置语法，具体参考stylus条件 11.循环语句sass支持for循环: 12345@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; 也支持while循环: 12345 $i: 6; @while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em $i; &#125; $i: $i - 2;&#125; 也可以使用@each命令进行循环: 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125;&#125; stylus只提供了一个for/in进行循环: 123for i in 1 2 3 4 5 6 7 8 9 .border-&#123;i&#125; border: solid blue unit(i, 'px') 12.自定义函数sass允许用户编写自己的函数: 123456@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125; stylus也允许用户编写自己的函数，函数的定义方式和mixin定义方式一样： 1234double(n) n * 2#sidebar width: double(5px) 除了可以给函数赋予默认参数之外，stylus的函数是允许返回多个值的： 1234width() 20px 10px width()[0] // 20px stylus作为nodejs的一个模块，提供了强大的javascript编程的能力，值得深究。","tags":[{"name":"library","slug":"library","permalink":"http://zhg.com/tags/library/"}]},{"title":"lodash","date":"2017-07-13T10:17:27.261Z","path":"2017/07/13/lodash/","text":"有多年开发经验的工程师，往往都会有自己的一套工具库，称为 utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制定和实现。 Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。 转载自 pinggod 的 http://www.jianshu.com/p/7436e40ac5d1 lodash中文文档 模块组成Lodash 提供的辅助函数主要分为以下几类，函数列表和用法实例请查看 Lodash 的官方文档 Array，适用于数组类型，比如填充数据、查找元素、数组分片等操作 Collection，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作 Function，适用于函数类型，比如节流、延迟、缓存、设置钩子等操作 Lang，普遍适用于各种类型，常用于执行类型判断和类型转换 Math，适用于数值类型，常用于执行数学运算 Number，适用于生成随机数，比较数值与数值区间的关系 Object，适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作 Seq，常用于创建链式调用，提高执行性能（惰性计算） String，适用于字符串类型 lodash/fp 模块提供了更接近函数式编程的开发方式，其内部的函数经过包装，具有 immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。Lodash 在 GitHub Wiki 中对 lodash/fp 的特点做了如下概述： Fixed Arity，固化参数个数，便于柯里化 Rearragned Arguments，重新调整参数位置，便于函数之间的聚合 Capped Iteratee Argument，封装 Iteratee 参数 New Methods In functional programming, an iteratee is a composable abstraction for incrementally processing sequentially presented chunks of input data in a purely functional fashion. With iteratees, it is possible to lazily transform how a resource will emit data, for example, by converting each chunk of the input to uppercase as they are retrieved or by limiting the data to only the five first chunks without loading the whole input data into memory. Iteratees are also responsible for opening and closing resources, providing predictable resource management. ———— iteratee, wikipedia 123456789101112131415161718192021222324252627282930313233// The `lodash/map` iteratee receives three arguments:// (value, index|key, collection)_.map(['6', '8', '10'], parseInt);// → [6, NaN, 2]// The `lodash/fp/map` iteratee is capped at one argument:// (value)fp.map(parseInt)(['6', '8', '10']);// → [6, 8, 10]// `lodash/padStart` accepts an optional `chars` param._.padStart('a', 3, '-')// → '--a'// `lodash/fp/padStart` does not.fp.padStart(3)('a');// → ' a'fp.padCharsStart('-')(3)('a');// → '--a'// `lodash/filter` is data-first iteratee-last:// (collection, iteratee)var compact = _.partial(_.filter, _, Boolean);compact(['a', null, 'c']);// → ['a', 'c']// `lodash/fp/filter` is iteratee-first data-last:// (iteratee, collection)var compact = fp.filter(Boolean);compact(['a', null, 'c']);// → ['a', 'c'] 在 React + Webpack + Babel(ES6) 的开发环境中，使用 Lodash 需要安装插件 babel-plugin-lodash 并更新 Babel 配置文件： 12npm install --save lodashnpm install --save-dev babel-plugin-lodash 更新 Babel 的配置文件 .babelrc 12345678910&#123; \"presets\": [ \"react\", \"es2015\", \"stage-0\" ], \"plugins\": [ \"lodash\" ]&#125; 使用方式： 12345import _ from 'lodash';import &#123; add &#125; from 'lodash/fp';const addOne = add(1);_.map([1, 2, 3], addOne); 性能 在 Filip Zawada 的文章《How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation》 中提到了 Lodash提高执行速度的思路，主要有三点：Lazy Evaluation、Pipelining 和 Deferred Execution。下面两张图来自 Filip 的博客： 假设有如上图所示的问题：从若干个球中取出三个面值小于 10 的球。第一步是从所有的球中取出所有面值小于 10 的球，第二步是从上一步的结果取三个球。 上图是另一种解决方案，如果一个球能够通过第一步，那么就继续执行第二步，直至结束然后测试下一个球……当我们取到三个球之后就中断整个循环。Filip 称这是 Lazy Evaluation Algorithm，就个人理解这并不全面，他后续提到的 Pipelining(管道计算)，再加上一个中断循环执行的算法应该更符合这里的图示。 此外，使用 Lodash 的链式调用时，只有显示或隐式调用 .value 方法才会对链式调用的整个操作进行取值，这种不在声明时立即求值，而在使用时求值的方式，是 Lazy Evaluation 最大的特点。 九个实例 受益于 Lodash 的普及程度，使用它可以提高多人开发时阅读代码的效率，减少彼此之间的误解（Loss of Consciousness）。在《Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting》一文中，作者列举了多个常用的 Lodash 函数，实例演示了使用 Lodash 的技巧。 1.N 次循环1234567891011121314// 1. Basic for loop.for(var i = 0; i &lt; 5; i++) &#123; // ...&#125;// 2. Using Array's join and split methodsArray.apply(null, Array(5)).forEach(function()&#123; // ...&#125;);// Lodash_.times(5, function()&#123; // ...&#125;); for 语句是执行循环的不二选择，Array.apply 也可以模拟循环，但在上面代码的使用场景下，_.times() 的解决方式更加简洁和易于理解。 2.深层查找属性值12345678910111213141516// Fetch the name of the first pet from each ownervar ownerArr = [&#123; \"owner\": \"Colin\", \"pets\": [&#123;\"name\":\"dog1\"&#125;, &#123;\"name\": \"dog2\"&#125;]&#125;, &#123; \"owner\": \"John\", \"pets\": [&#123;\"name\":\"dog3\"&#125;, &#123;\"name\": \"dog4\"&#125;]&#125;];// Array's map method.ownerArr.map(function(owner)&#123; return owner.pets[0].name;&#125;);// Lodash_.map(ownerArr, 'pets[0].name'); _.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用 jQuery 选择 DOM 节点 ul &gt; li &gt; a，对于前端开发者来说有种久违的亲切感。 3.个性化数组1234567891011// Array's map method.Array.apply(null, Array(6)).map(function(item, index)&#123; return \"ball_\" + index;&#125;);// Lodash_.times(6, _.uniqueId.bind(null, 'ball_'));// Lodash_.times(6, _.partial(_.uniqueId, 'ball_'));// eg. [ball_0, ball_1, ball_2, ball_3, ball_4, ball_5] 在上面的代码中，我们要创建一个初始值不同、长度为 6 的数组，其中 _.uniqueId 方法用于生成独一无二的标识符（递增的数字，在程序运行期间保持独一无二），_partial 方法是对 bind 的封装。 4.深拷贝12345678910var objA = &#123; \"name\": \"colin\"&#125;// Normal method? Too long. See Stackoverflow for solution:// http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript// Lodashvar objB = _.cloneDeep(objA);objB === objA // false JavaScript 没有直接提供深拷贝的函数，但我们可以用其他函数来模拟，比如 JSON.parse(JSON.stringify(objectToClone))，但这种方法要求对象中的属性值不能是函数。Lodash 中的 _.cloneDeep 函数封装了深拷贝的逻辑，用起来更加简洁。 5.随机数123456789// Naive utility methodfunction getRandomNumber(min, max)&#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;getRandomNumber(15, 20);// Lodash_.random(15, 20); Lodash 的随机数生成函数更贴近实际开发，ECMAScript 的随机数生成函数是底层必备的接口，两者都不可或缺。此外，使用 _.random(15, 20, true) 还可以在 15 到 20 之间生成随机的浮点数。 6.对象扩展1234567891011121314151617// Adding extend function to Object.prototypeObject.prototype.extend = function(obj) &#123; for (var i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; this[i] = obj[i]; &#125; &#125;&#125;;var objA = &#123;\"name\": \"colin\", \"car\": \"suzuki\"&#125;;var objB = &#123;\"name\": \"james\", \"age\": 17&#125;;objA.extend(objB);objA; // &#123;\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"&#125;;// Lodash_.assign(objA, objB); _.assign 是浅拷贝，和 ES6 新增的 Ojbect.assign 函数功能一致（建议优先使用 Object.assign）。 7.筛选属性1234567891011121314151617181920// Naive method: Remove an array of keys from objectObject.prototype.remove = function(arr) &#123; var that = this; arr.forEach(function(key)&#123; delete(that[key]); &#125;);&#125;;var objA = &#123;\"name\": \"colin\", \"car\": \"suzuki\", \"age\": 17&#125;;objA.remove(['car', 'age']);objA; // &#123;\"name\": \"colin\"&#125;// LodashobjA = _.omit(objA, ['car', 'age']);// =&gt; &#123;\"name\": \"colin\"&#125;objA = _.omit(objA, 'car');// =&gt; &#123;\"name\": \"colin\", \"age\": 17&#125;;objA = _.omit(objA, _.isNumber);// =&gt; &#123;\"name\": \"colin\"&#125;; 大多数情况下，Lodash 所提供的辅助函数都会比原生的函数更贴近开发需求。在上面的代码中，开发者可以使用数组、字符串以及函数的方式筛选对象的属性，并且最终会返回一个新的对象，中间执行筛选时不会对旧对象产生影响。 12345678910111213141516171819// Naive method: Returning a new object with selected propertiesObject.prototype.pick = function(arr) &#123; var _this = this; var obj = &#123;&#125;; arr.forEach(function(key)&#123; obj[key] = _this[key]; &#125;); return obj;&#125;;var objA = &#123;\"name\": \"colin\", \"car\": \"suzuki\", \"age\": 17&#125;;var objB = objA.pick(['car', 'age']);// &#123;\"car\": \"suzuki\", \"age\": 17&#125;// Lodashvar objB = _.pick(objA, ['car', 'age']);// &#123;\"car\": \"suzuki\", \"age\": 17&#125; .pick 是 .omit 的相反操作，用于从其他对象中挑选属性生成新的对象。 8.随机元素1234567891011121314var luckyDraw = [\"Colin\", \"John\", \"James\", \"Lily\", \"Mary\"];function pickRandomPerson(luckyDraw)&#123; var index = Math.floor(Math.random() * (luckyDraw.length -1)); return luckyDraw[index];&#125;pickRandomPerson(luckyDraw); // John// Lodash_.sample(luckyDraw); // Colin// Lodash - Getting 2 random item_.sample(luckyDraw, 2); // ['John','Lily'] _.sample 支持随机挑选多个元素并返回心的数组。 9.针对 JSON.parse 的错误处理12345678910111213141516171819202122232425// Using try-catch to handle the JSON.parse errorfunction parse(str)&#123; try &#123; return JSON.parse(str); &#125; catch(e) &#123; return false; &#125;&#125;// With Lodashfunction parseLodash(str)&#123; return _.attempt(JSON.parse.bind(null, str));&#125;parse('a');// =&gt; falseparseLodash('a');// =&gt; Return an error objectparse('&#123;\"name\": \"colin\"&#125;');// =&gt; Return &#123;\"name\": \"colin\"&#125;parseLodash('&#123;\"name\": \"colin\"&#125;');// =&gt; Return &#123;\"name\": \"colin\"&#125; 如果你在使用 JSON.parse 时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接收的 JSON 对象都是有效的。try-catch 是最常见的错误处理方式，如果项目中 Lodash，那么可以使用 _.attmpt 替代 try-catch 的方式，当解析 JSON 出错时，该方法会返回一个 Error 对象。 随着 ES6 的普及，Lodash 的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数，有关 ES6 替代 Lodash 的部分，请参考文章《10 Lodash Features You Can Replace with ES6》（中文版《10 个可用 ES6 替代的 Lodash 特性》）。 其中有两处非常值得一看： 1234567891011121314151617181920212223242526272829303132333435// 使用箭头函数创建可复用的路径const object = &#123; 'a': [&#123; 'b': &#123; 'c': 3 &#125; &#125;, 4] &#125;;[ obj =&gt; obj.a[0].b.c, obj =&gt; obj.a[1]].map(path =&gt; path(object));// 使用箭头函数编写链式调用const pipe = functions =&gt; data =&gt; &#123; return functions.reduce( (value, func) =&gt; func(value), data );&#125;;const pipeline = pipe([ x =&gt; x * 2, x =&gt; x / 3, x =&gt; x &gt; 5, b =&gt; !b]);pipeline(5);// truepipeline(20);// false在 ES6 中，如果一个函数只接收一个形参且函数体是一个 return 语句，就可以使用箭头函数简化为：const func = p =&gt; v;// 类似于(不完全相同)const func = function (p) &#123; return v;&#125; 当有多重嵌套时，可以简化为： 123456789101112const func = a =&gt; b =&gt; c =&gt; a + b + c;func(1)(2)(3);// =&gt; 6// 类似于const func = function (a) &#123; return function (b) &#123; return function (e) &#123; return a + b + c; &#125; &#125;&#125; 参考资料 Lodash 官方文档 Lodash FP Guide babel-plugin-lodash How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting 10 Lodash Features You Can Replace with ES6 Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting","tags":[{"name":"library","slug":"library","permalink":"http://zhg.com/tags/library/"}]},{"title":"cygwin常用命令收集","date":"2017-07-13T09:05:28.478Z","path":"2017/07/13/cygwin常用命令收集/","text":"cygwin是一个在windows平台上运行的unix模拟环境，是cygnussolutions公司开发的自由软件。它对于学习unix/linux操作环境，或者从unix到windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用gnu工具集在windows上进行嵌入式系统开发，非常有用。官网 基本操作命令: 1234ls #以默认方式显示当前目录文件列表ls –a #显示所有文件包括隐藏文件ls –l #显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行ls --color=never *.so &gt; obj #不显示文字颜色,将所有so文件记录到obj文件中 12345cd dir #切换到当前目录下的dir目录cd / #切换到根目录cd .. #切换到到上一级目录cd ../.. #切换到上二级目录cd ~ #切换到用户目录，比如是root用户，则切换到/root下 12rm file #删除某一个文件rm -fr dir #删除当前目录下叫dir的整个目录 12345cp source target #将文件source 复制为 targetcp /root/source . #将/root下的文件source复制到当前目录cp –av soure_dir target_dir #将整个目录复制，两目录完全一样cp –fr source_dir target_dir #将整个目录复制，并且是以非链接方式复制，当source目录带有符号链接时，两个目录不相同 mv source target #将文件source更名为target 1234567891011diff dir1 dir2 #比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出diff file1 file2 #比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的comm file1 file2 #比较文件，显示两个文件不相同的内容echo message #显示一串字符echo \"message message2\" #显示不连续的字符串cat:cat file #显示文件的内容，和DOS的type相同cat file | more #显示文件的内容并传输到more程序实现分页显示，使用命令less file可实现相同的功能more #分页命令，一般通过管道将内容传给它，如ls | more 1234567export LC_ALL=zh_CN.GB2312 #将环境变量LC_ALL的值设为zh_CN.GB2312export DISPLAY=0:0 #通过该设置，当前字符终端下运行的图形程序可直接运行于Xserverdate #显示当前日期时间date -s 20:30:30 #设置系统时间为20:30:30date -s 2002-3-5 #设置系统时期为2003-3-5clock –r #对系统Bios中读取时间参数clock –w #将系统时间(如由date设置的时间)写入Bios 1eject #umout掉CDROM并将光碟弹出，但cdrom不能处于busy的状态，否则无效 1234du #计算当前目录的容量du -sm /root #计算/root目录的容量并以M为单位find -name /path file #在/path目录下查找看是否有文件filegrep -ir “chars” #在当前目录的所有文件查找字串chars，并忽略大小写，-i为大小写，-r为下一级目录 123vi file #编辑文件filevi 原基本使用及命令： 输入命令的方式为先按ctrl+c， 然后输入:x(退出),:x!(退出并保存) :w(写入文件),:w!(不询问方式写入文件）， :r file(读文件file) ,:%s/oldchars/newchars/g(将所有字串oldchars换成newchars) 这一类的命令进行操作 12man ls #读取关于ls命令的帮助man ls | grep color #读取关于ls命令的帮助并通过grep程序在其中查找color字串 12startx #运行Linux图形有环境Xfree86 #只运行X图形server 12345reboot #重新启动计算机halt #关闭计算机init 0 #关闭所有应用程序和服务，进入纯净的操作环境init 1 #重新启动应用及服务init 6 #重新启动计算机 扩展命令 1234567tar xfzv file.tgz #将文件file.tgz解压tar xfzv file.tgz -C target_path #将文件file.tgz解压到target_path目录下tar cfzv file.tgz source_path #将文件source_path压缩为file.tgztar c directory &gt; directory.tar #将目录directory打包成不压缩的directory.targzip directory.tar #将覆盖原文件生成压缩的 directory.tar.gzgunzip directory.tar.gz #覆盖原文件解压生成不压缩的 directory.tar。tar xf directory.tar #可将不压缩的文件解包 123dmesg #显示kernle启动及驱动装载信息uname #显示操作系统的类型uname -R #显示操作系统内核的version 1strings file 显示file文件中的ASCII字符内容 1234567rpm -ihv program.rpm #安装程序program并显示安装进程rpm2targz program.rpm program.tgz #将rpm格式的文件转换成tarball格式su root #切换到超级用户sulogin /dev/tty4 #在tty4即alt+F4终端等待用户登陆或直接登陆开启一个shellchmod a+x file #将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行chmod 666 file #将文件file设置为可读写chown user /dir #将/dir目录设置为user所有 12mknod /dev/hda1 b 3 1 #创建块设备hda1，主设备号为3，从设备号为1，即master硬盘的的第一个分区mknod /dev/tty1 c 4 1 #创建字符设备tty1,主设备号为4，众设备号为1，即第一个tty终端 1touch /tmp/running #在/tmp下创建一个临时文件running，重新启动后消失 1sleep 9 #系统挂起9秒钟的时间 1234lpd stop 或 cups stop #停止打印服务程序lpd start 或 cups start #启动打印服务程序lpd restart 或 cups restart #重新启动打印服务程序lpr file.txt #打印文件file.txt 123456789101112131415161718fdisk /dev/hda #就像执行了dos的fdisk一样cfdisk /dev/hda #比fdisk界面稍为友好些mount -t ext2 /dev/hda1 /mnt #把/dev/hda1装载到 /mnt目录df #显示文件系统装载的相关信息 mount -t iso9660 /dev/cdrom /mnt/cdrom #将光驱加载到/mnt/cdrom目录mount-t smb //192.168.1.5/sharedir /mnt -o username=tomlinux,password=tomlinux #将windows的的共享目录加载到/mnt/smb目录，用户名及密码均为tomlinuxmount -t nfs 192.168.1.1:/sharedir /mnt #将nfs服务的共享目录sharedir加载到/mnt/nfs目录umount /mnt #将/mnt目录卸载，/mnt目录必须处于空闲状态umount /dev/hda1 #将/dev/hda1设备卸载，设备必须处于空亲状态sync #将cache中的内容与磁盘同步，在Linux中复制文件，一般要系统空闲才去写文件e2fsck /dev/hda1 #检查/dev/hda1是否有文件系统错误，提示修复方式e2fsck -p /dev/hda1#检查/dev/hda1是否有错误，如果有则自动修复e2fsck -y /dev/hda1#检查错误，所有提问均于yes方式执行e2fsck -c /dev/hda1#检查磁盘是否有坏区mkfs /dev/hda1 #格式化/dev/hda1为ext2格式mkfs.minix /dev/hda1 #格式化/dev/hda1为minix格式文件系统mfks /dev/hda9 #格工化/dev/hda9为Linux swap格式swapon /dev/hda9 #将swap分区装载当作内存来用 123456lilo #运行lilo程序，程序自动查找/etc/lilo.conf并按该配置生效lilo -C /root/lilo.conf #lilo程序按/root/lilo.conf配置生效grub #在Linux shell状态下运行boot loader设置程序grub-install #安装grub磁盘引导程序，成功后升级内核无须像lilo一样要重新启动系统，只需修改/etc/grub.conf即可实现新引导配置rdev bzImage #显示kernel的根分区信息rdev bzImage /dev/hda1 #将kernel的根分区设置为/dev/hda1，这在没有lilo等引导程序的系统中非常重要. 12345dd if=/dev/fd0 of=floppy.fd #将软盘的内容复制成一个镜像，功能与旧石器时代常用的hd-copy相同dd if=/dev/zero of=root.ram bs=1024,count=1024 #生成一个大小为1M的块设备，可以把它当作硬盘的一个分区来用mkfs root.ram #将块设备格式化为ext2格式dd if=root.ram of=/dev/ram0 #将init.rd格式的root.ram的内容导入内存mount /dev/ram0 /mnt #ramdisk /dev/ram0装载到/mnt 目录 12345gcc hello.c #将hello.c编译成名为a.out二进制执行文件gcc hello.c -o hello #将hello.c编译成名为hello的二进制执行文件gcc -static -o hello hello.c #将hello.c编译成名为hello的二进制静态执行文件ldd program #显示程序所使用了哪些库objcopy -S program #将程序中的符号表及无用的调试信息去掉，可以小很多 12345678strace netscape #跟踪程序netscape的执行，看调用的库，环境变量设置，配置文件，使用的设备，调用的其它应用程序等，在strace下，程序干了什么东东一目了然。ps #显示当前系统进程信息ps –ef #显示系统所有进程信息kill -9 500 #将进程编号为500的程序干掉killall -9 netscape #将所有名字为netscape的程序杀死，kill不是万能的，对僵死的程序则无效。top #显示系统进程的活动情况，按占CPU资源百分比来分free #显示系统内存及swap使用情况time program #在program程序结束后，将计算出program运行所使用的时间 12345678910111213141516171819202122chroot . #将根目录切换至当前目录,调试新系统时使用chroot /tomlinux #将根目录切换至/tomlinux目录chroot /tomlinux sbin/init #将根目录切换至/tomlinux并执行sbin/initadduser id #增加一个叫id的用户userdel id #增除叫id的用户userlist #显示已登陆的用户列表passwd id #修改用户id的密码passwd -d root #将root用户的密码删除chown id /work #指定/work目录为id用户所拥有ifconfig eth0 192.168.1.1 netmask 255.255.255.0 #设置网卡1的地址192.168.1.1，掩码为255.255.255.0，不写netmask参数则默认为255.255.255.0ifconfig eth0:1 192.168.1.2 #捆绑网卡1的第二个地址为192.168.1.2ifconfig eth0:x 192.168.1.x #捆绑网卡1的第二个地址为192.168.1.xifconfig down eth1 #关闭第二块网卡，使其停止工作hostname -F tomlinux.com #将主机名设置为tomlinux.comroute #显示当前路由设置情况route add default gw 192.168.1.1 metric 1 #设置192.168.1.1为默认的路由route del default #将默认的路由删除dhcp #启动dhcp服务dhclient #启动dhcp终端并自动获取IP地址ping 163.com #测试与163.com的连接ping 202.96.128.68 #测试与IP 202。96.128.68的连接 1234567probe rtl8139 #检查驱动程序rtl8139.o是否正常工作lsmod #显示已装载的驱动程序insmod rtl8139.o #装载驱动程序rtl8139.oinsmod sb.o io=0x280 irq=7 dma=3 dma16=7 mpu_io=330 #装载驱动程序并设置相关的irq,dma参数rmmod rtl8139 #删除名为rtl8139的驱动模块gpm -k #停止字符状态下的mouse服务gpm -t ps2 #在字符状态下以ps2类型启动mouse的服务 123telnet 192.168.1.1 #登陆IP为192.168.1.1的telnet服务器telnet iserver.com #登陆域名为iserver.com的telnet服务器ftp 192.168.1.1 或 ftp iserver.com #登陆到ftp服务 * Linux开发中的常用命令(cygwin环境也同样适用)","tags":[{"name":"cli","slug":"cli","permalink":"http://zhg.com/tags/cli/"}]}]