[{"title":"lodash","date":"2017-07-13T10:17:27.261Z","path":"2017/07/13/lodash/","text":"有多年开发经验的工程师，往往都会有自己的一套工具库，称为 utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制定和实现。Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。 转载自 pinggod 的 http://www.jianshu.com/p/7436e40ac5d1 lodash中文文档 模块组成Lodash 提供的辅助函数主要分为以下几类，函数列表和用法实例请查看 Lodash 的官方文档 Array，适用于数组类型，比如填充数据、查找元素、数组分片等操作 Collection，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作 Function，适用于函数类型，比如节流、延迟、缓存、设置钩子等操作 Lang，普遍适用于各种类型，常用于执行类型判断和类型转换 Math，适用于数值类型，常用于执行数学运算 Number，适用于生成随机数，比较数值与数值区间的关系 Object，适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作 Seq，常用于创建链式调用，提高执行性能（惰性计算） String，适用于字符串类型 lodash/fp 模块提供了更接近函数式编程的开发方式，其内部的函数经过包装，具有 immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。Lodash 在 GitHub Wiki 中对 lodash/fp 的特点做了如下概述： Fixed Arity，固化参数个数，便于柯里化 Rearragned Arguments，重新调整参数位置，便于函数之间的聚合 Capped Iteratee Argument，封装 Iteratee 参数 New Methods In functional programming, an iteratee is a composable abstraction for incrementally processing sequentially presented chunks of input data in a purely functional fashion. With iteratees, it is possible to lazily transform how a resource will emit data, for example, by converting each chunk of the input to uppercase as they are retrieved or by limiting the data to only the five first chunks without loading the whole input data into memory. Iteratees are also responsible for opening and closing resources, providing predictable resource management. ———— iteratee, wikipedia // Thelodash/map` iteratee receives three arguments:// (value, index|key, collection)_.map([‘6’, ‘8’, ‘10’], parseInt);// → [6, NaN, 2] // The lodash/fp/map iteratee is capped at one argument:// (value)fp.map(parseInt)([‘6’, ‘8’, ‘10’]);// → [6, 8, 10] // lodash/padStart accepts an optional chars param._.padStart(‘a’, 3, ‘-‘)// → ‘–a’ // lodash/fp/padStart does not.fp.padStart(3)(‘a’);// → ‘ a’fp.padCharsStart(‘-‘)(3)(‘a’);// → ‘–a’ // lodash/filter is data-first iteratee-last:// (collection, iteratee)var compact = .partial(.filter, _, Boolean);compact([‘a’, null, ‘c’]);// → [‘a’, ‘c’] // lodash/fp/filter is iteratee-first data-last:// (iteratee, collection)var compact = fp.filter(Boolean);compact([‘a’, null, ‘c’]);// → [‘a’, ‘c’] `在 React + Webpack + Babel(ES6) 的开发环境中，使用 Lodash 需要安装插件 babel-plugin-lodash 并更新 Babel 配置文件： npm install --save lodash npm install --save-dev babel-plugin-lodash 更新 Babel 的配置文件 .babelrc { &quot;presets&quot;: [ &quot;react&quot;, &quot;es2015&quot;, &quot;stage-0&quot; ], &quot;plugins&quot;: [ &quot;lodash&quot; ] }使用方式： `import _ from ‘lodash’;import { add } from ‘lodash/fp’; const addOne = add(1);_.map([1, 2, 3], addOne);` 性能在 Filip Zawada 的文章《How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation》 中提到了 Lodash提高执行速度的思路，主要有三点：Lazy Evaluation、Pipelining 和 Deferred Execution。下面两张图来自 Filip 的博客： 假设有如上图所示的问题：从若干个球中取出三个面值小于 10 的球。第一步是从所有的球中取出所有面值小于 10 的球，第二步是从上一步的结果取三个球。 上图是另一种解决方案，如果一个球能够通过第一步，那么就继续执行第二步，直至结束然后测试下一个球……当我们取到三个球之后就中断整个循环。Filip 称这是 Lazy Evaluation Algorithm，就个人理解这并不全面，他后续提到的 Pipelining(管道计算)，再加上一个中断循环执行的算法应该更符合这里的图示。 此外，使用 Lodash 的链式调用时，只有显示或隐式调用 .value 方法才会对链式调用的整个操作进行取值，这种不在声明时立即求值，而在使用时求值的方式，是 Lazy Evaluation 最大的特点。 九个实例受益于 Lodash 的普及程度，使用它可以提高多人开发时阅读代码的效率，减少彼此之间的误解（Loss of Consciousness）。在《Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting》一文中，作者列举了多个常用的 Lodash 函数，实例演示了使用 Lodash 的技巧。 1.N 次循环`// 1. Basic for loop.for(var i = 0; i &lt; 5; i++) { // …} // 2. Using Array’s join and split methodsArray.apply(null, Array(5)).forEach(function(){ // …}); // Lodash_.times(5, function(){ // …}); 作者：pinggod链接：http://www.jianshu.com/p/7436e40ac5d1來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。` for 语句是执行循环的不二选择，Array.apply 也可以模拟循环，但在上面代码的使用场景下，_.times() 的解决方式更加简洁和易于理解。 2.深层查找属性值`// Fetch the name of the first pet from each ownervar ownerArr = [{ “owner”: “Colin”, “pets”: [{“name”:”dog1”}, {“name”: “dog2”}]}, { “owner”: “John”, “pets”: [{“name”:”dog3”}, {“name”: “dog4”}]}]; // Array’s map method.ownerArr.map(function(owner){ return owner.pets[0].name;}); // Lodash_.map(ownerArr, ‘pets[0].name’); ` _.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用 jQuery 选择 DOM 节点 ul &gt; li &gt; a，对于前端开发者来说有种久违的亲切感。 3.个性化数组`// Array’s map method.Array.apply(null, Array(6)).map(function(item, index){ return “ball_” + index;}); // Lodash.times(6, .uniqueId.bind(null, ‘ball_’)); // Lodash.times(6, .partial(.uniqueId, ‘ball‘));// eg. [ball_0, ball_1, ball_2, ball_3, ball_4, ball_5] 作者：pinggod链接：http://www.jianshu.com/p/7436e40ac5d1來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。` 在上面的代码中，我们要创建一个初始值不同、长度为 6 的数组，其中 _.uniqueId 方法用于生成独一无二的标识符（递增的数字，在程序运行期间保持独一无二），_partial 方法是对 bind 的封装。 4.深拷贝`var objA = { “name”: “colin”} // Normal method? Too long. See Stackoverflow for solution:// http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript // Lodashvar objB = _.cloneDeep(objA);objB === objA // false ` JavaScript 没有直接提供深拷贝的函数，但我们可以用其他函数来模拟，比如 JSON.parse(JSON.stringify(objectToClone))，但这种方法要求对象中的属性值不能是函数。Lodash 中的 _.cloneDeep 函数封装了深拷贝的逻辑，用起来更加简洁。 5.随机数`// Naive utility methodfunction getRandomNumber(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min;} getRandomNumber(15, 20); // Lodash_.random(15, 20); ` Lodash 的随机数生成函数更贴近实际开发，ECMAScript 的随机数生成函数是底层必备的接口，两者都不可或缺。此外，使用 _.random(15, 20, true) 还可以在 15 到 20 之间生成随机的浮点数。 6.对象扩展`// Adding extend function to Object.prototypeObject.prototype.extend = function(obj) { for (var i in obj) { if (obj.hasOwnProperty(i)) { this[i] = obj[i]; } }}; var objA = {“name”: “colin”, “car”: “suzuki”};var objB = {“name”: “james”, “age”: 17}; objA.extend(objB);objA; // {“name”: “james”, “age”: 17, “car”: “suzuki”}; // Lodash_.assign(objA, objB); ` _.assign 是浅拷贝，和 ES6 新增的 Ojbect.assign 函数功能一致（建议优先使用 Object.assign）。 7.筛选属性`// Naive method: Remove an array of keys from objectObject.prototype.remove = function(arr) { var that = this; arr.forEach(function(key){ delete(that[key]); });}; var objA = {“name”: “colin”, “car”: “suzuki”, “age”: 17}; objA.remove([‘car’, ‘age’]);objA; // {“name”: “colin”} // LodashobjA = .omit(objA, [‘car’, ‘age’]);// =&gt; {“name”: “colin”}objA = .omit(objA, ‘car’);// =&gt; {“name”: “colin”, “age”: 17};objA = .omit(objA, .isNumber);// =&gt; {“name”: “colin”}; ` 大多数情况下，Lodash 所提供的辅助函数都会比原生的函数更贴近开发需求。在上面的代码中，开发者可以使用数组、字符串以及函数的方式筛选对象的属性，并且最终会返回一个新的对象，中间执行筛选时不会对旧对象产生影响。 `// Naive method: Returning a new object with selected propertiesObject.prototype.pick = function(arr) { var _this = this; var obj = {}; arr.forEach(function(key){ obj[key] = _this[key]; }); return obj; }; var objA = {“name”: “colin”, “car”: “suzuki”, “age”: 17}; var objB = objA.pick([‘car’, ‘age’]);// {“car”: “suzuki”, “age”: 17} // Lodashvar objB = _.pick(objA, [‘car’, ‘age’]);// {“car”: “suzuki”, “age”: 17} ` .pick 是 .omit 的相反操作，用于从其他对象中挑选属性生成新的对象。 8.随机元素`var luckyDraw = [“Colin”, “John”, “James”, “Lily”, “Mary”]; function pickRandomPerson(luckyDraw){ var index = Math.floor(Math.random() * (luckyDraw.length -1)); return luckyDraw[index];} pickRandomPerson(luckyDraw); // John // Lodash_.sample(luckyDraw); // Colin // Lodash - Getting 2 random item_.sample(luckyDraw, 2); // [‘John’,’Lily’] ` _.sample 支持随机挑选多个元素并返回心的数组。 9.针对 JSON.parse 的错误处理`// Using try-catch to handle the JSON.parse errorfunction parse(str){ try { return JSON.parse(str); } catch(e) { return false; } } // With Lodashfunction parseLodash(str){ return _.attempt(JSON.parse.bind(null, str));} parse(‘a’);// =&gt; falseparseLodash(‘a’);// =&gt; Return an error object parse(‘{“name”: “colin”}’);// =&gt; Return {“name”: “colin”}parseLodash(‘{“name”: “colin”}’);// =&gt; Return {“name”: “colin”} ` 如果你在使用 JSON.parse 时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接收的 JSON 对象都是有效的。try-catch 是最常见的错误处理方式，如果项目中 Lodash，那么可以使用 _.attmpt 替代 try-catch 的方式，当解析 JSON 出错时，该方法会返回一个 Error 对象。 随着 ES6 的普及，Lodash 的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数，有关 ES6 替代 Lodash 的部分，请参考文章《10 Lodash Features You Can Replace with ES6》（中文版《10 个可用 ES6 替代的 Lodash 特性》）。 其中有两处非常值得一看： `// 使用箭头函数创建可复用的路径const object = { ‘a’: [{ ‘b’: { ‘c’: 3 } }, 4] }; [ obj =&gt; obj.a[0].b.c, obj =&gt; obj.a[1]].map(path =&gt; path(object)); // 使用箭头函数编写链式调用const pipe = functions =&gt; data =&gt; { return functions.reduce( (value, func) =&gt; func(value), data );}; const pipeline = pipe([ x =&gt; x * 2, x =&gt; x / 3, x =&gt; x &gt; 5, b =&gt; !b]); pipeline(5);// truepipeline(20);// false在 ES6 中，如果一个函数只接收一个形参且函数体是一个 return 语句，就可以使用箭头函数简化为： const func = p =&gt; v; // 类似于(不完全相同)const func = function (p) { return v;} ` 当有多重嵌套时，可以简化为： `const func = a =&gt; b =&gt; c =&gt; a + b + c;func(1)(2)(3);// =&gt; 6 // 类似于const func = function (a) { return function (b) { return function (e) { return a + b + c; } }} ` 参考资料 Lodash 官方文档 Lodash FP Guide babel-plugin-lodash How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting 10 Lodash Features You Can Replace with ES6 Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting","tags":[]},{"title":"cygwin常用命令收集","date":"2017-07-13T09:05:28.478Z","path":"2017/07/13/cygwin常用命令收集/","text":"cygwin是一个在windows平台上运行的unix模拟环境，是cygnussolutions公司开发的自由软件。它对于学习unix/linux操作环境，或者从unix到windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用gnu工具集在windows上进行嵌入式系统开发，非常有用。官网 基本操作命令: 1234ls #以默认方式显示当前目录文件列表ls –a #显示所有文件包括隐藏文件ls –l #显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行ls --color=never *.so &gt; obj #不显示文字颜色,将所有so文件记录到obj文件中 12345cd dir #切换到当前目录下的dir目录cd / #切换到根目录cd .. #切换到到上一级目录cd ../.. #切换到上二级目录cd ~ #切换到用户目录，比如是root用户，则切换到/root下 12rm file #删除某一个文件rm -fr dir #删除当前目录下叫dir的整个目录 12345cp source target #将文件source 复制为 targetcp /root/source . #将/root下的文件source复制到当前目录cp –av soure_dir target_dir #将整个目录复制，两目录完全一样cp –fr source_dir target_dir #将整个目录复制，并且是以非链接方式复制，当source目录带有符号链接时，两个目录不相同 mv source target #将文件source更名为target 12345678910111213141516diff dir1 dir2 #比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出diff file1 file2 #比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的comm file1 file2 #比较文件，显示两个文件不相同的内容``` ***``` bashecho message #显示一串字符echo \"message message2\" #显示不连续的字符串cat:cat file #显示文件的内容，和DOS的type相同cat file | more #显示文件的内容并传输到more程序实现分页显示，使用命令less file可实现相同的功能more #分页命令，一般通过管道将内容传给它，如ls | more 1234567export LC_ALL=zh_CN.GB2312 #将环境变量LC_ALL的值设为zh_CN.GB2312export DISPLAY=0:0 #通过该设置，当前字符终端下运行的图形程序可直接运行于Xserverdate #显示当前日期时间date -s 20:30:30 #设置系统时间为20:30:30date -s 2002-3-5 #设置系统时期为2003-3-5clock –r #对系统Bios中读取时间参数clock –w #将系统时间(如由date设置的时间)写入Bios 1eject #umout掉CDROM并将光碟弹出，但cdrom不能处于busy的状态，否则无效 1234du #计算当前目录的容量du -sm /root #计算/root目录的容量并以M为单位find -name /path file #在/path目录下查找看是否有文件filegrep -ir “chars” #在当前目录的所有文件查找字串chars，并忽略大小写，-i为大小写，-r为下一级目录 123vi file #编辑文件filevi 原基本使用及命令： 输入命令的方式为先按ctrl+c， 然后输入:x(退出),:x!(退出并保存) :w(写入文件),:w!(不询问方式写入文件）， :r file(读文件file) ,:%s/oldchars/newchars/g(将所有字串oldchars换成newchars) 这一类的命令进行操作 12man ls #读取关于ls命令的帮助man ls | grep color #读取关于ls命令的帮助并通过grep程序在其中查找color字串 12startx #运行Linux图形有环境Xfree86 #只运行X图形server 12345reboot #重新启动计算机halt #关闭计算机init 0 #关闭所有应用程序和服务，进入纯净的操作环境init 1 #重新启动应用及服务init 6 #重新启动计算机 扩展命令 1234567tar xfzv file.tgz #将文件file.tgz解压tar xfzv file.tgz -C target_path #将文件file.tgz解压到target_path目录下tar cfzv file.tgz source_path #将文件source_path压缩为file.tgztar c directory &gt; directory.tar #将目录directory打包成不压缩的directory.targzip directory.tar #将覆盖原文件生成压缩的 directory.tar.gzgunzip directory.tar.gz #覆盖原文件解压生成不压缩的 directory.tar。tar xf directory.tar #可将不压缩的文件解包 123dmesg #显示kernle启动及驱动装载信息uname #显示操作系统的类型uname -R #显示操作系统内核的version 1strings file 显示file文件中的ASCII字符内容 1234567rpm -ihv program.rpm #安装程序program并显示安装进程rpm2targz program.rpm program.tgz #将rpm格式的文件转换成tarball格式su root #切换到超级用户sulogin /dev/tty4 #在tty4即alt+F4终端等待用户登陆或直接登陆开启一个shellchmod a+x file #将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行chmod 666 file #将文件file设置为可读写chown user /dir #将/dir目录设置为user所有 12mknod /dev/hda1 b 3 1 #创建块设备hda1，主设备号为3，从设备号为1，即master硬盘的的第一个分区mknod /dev/tty1 c 4 1 #创建字符设备tty1,主设备号为4，众设备号为1，即第一个tty终端 1touch /tmp/running #在/tmp下创建一个临时文件running，重新启动后消失 1sleep 9 #系统挂起9秒钟的时间 1234lpd stop 或 cups stop #停止打印服务程序lpd start 或 cups start #启动打印服务程序lpd restart 或 cups restart #重新启动打印服务程序lpr file.txt #打印文件file.txt 123456789101112131415161718fdisk /dev/hda #就像执行了dos的fdisk一样cfdisk /dev/hda #比fdisk界面稍为友好些mount -t ext2 /dev/hda1 /mnt #把/dev/hda1装载到 /mnt目录df #显示文件系统装载的相关信息 mount -t iso9660 /dev/cdrom /mnt/cdrom #将光驱加载到/mnt/cdrom目录mount-t smb //192.168.1.5/sharedir /mnt -o username=tomlinux,password=tomlinux #将windows的的共享目录加载到/mnt/smb目录，用户名及密码均为tomlinuxmount -t nfs 192.168.1.1:/sharedir /mnt #将nfs服务的共享目录sharedir加载到/mnt/nfs目录umount /mnt #将/mnt目录卸载，/mnt目录必须处于空闲状态umount /dev/hda1 #将/dev/hda1设备卸载，设备必须处于空亲状态sync #将cache中的内容与磁盘同步，在Linux中复制文件，一般要系统空闲才去写文件e2fsck /dev/hda1 #检查/dev/hda1是否有文件系统错误，提示修复方式e2fsck -p /dev/hda1#检查/dev/hda1是否有错误，如果有则自动修复e2fsck -y /dev/hda1#检查错误，所有提问均于yes方式执行e2fsck -c /dev/hda1#检查磁盘是否有坏区mkfs /dev/hda1 #格式化/dev/hda1为ext2格式mkfs.minix /dev/hda1 #格式化/dev/hda1为minix格式文件系统mfks /dev/hda9 #格工化/dev/hda9为Linux swap格式swapon /dev/hda9 #将swap分区装载当作内存来用 123456lilo #运行lilo程序，程序自动查找/etc/lilo.conf并按该配置生效lilo -C /root/lilo.conf #lilo程序按/root/lilo.conf配置生效grub #在Linux shell状态下运行boot loader设置程序grub-install #安装grub磁盘引导程序，成功后升级内核无须像lilo一样要重新启动系统，只需修改/etc/grub.conf即可实现新引导配置rdev bzImage #显示kernel的根分区信息rdev bzImage /dev/hda1 #将kernel的根分区设置为/dev/hda1，这在没有lilo等引导程序的系统中非常重要. 12345dd if=/dev/fd0 of=floppy.fd #将软盘的内容复制成一个镜像，功能与旧石器时代常用的hd-copy相同dd if=/dev/zero of=root.ram bs=1024,count=1024 #生成一个大小为1M的块设备，可以把它当作硬盘的一个分区来用mkfs root.ram #将块设备格式化为ext2格式dd if=root.ram of=/dev/ram0 #将init.rd格式的root.ram的内容导入内存mount /dev/ram0 /mnt #ramdisk /dev/ram0装载到/mnt 目录 12345gcc hello.c #将hello.c编译成名为a.out二进制执行文件gcc hello.c -o hello #将hello.c编译成名为hello的二进制执行文件gcc -static -o hello hello.c #将hello.c编译成名为hello的二进制静态执行文件ldd program #显示程序所使用了哪些库objcopy -S program #将程序中的符号表及无用的调试信息去掉，可以小很多 12345678strace netscape #跟踪程序netscape的执行，看调用的库，环境变量设置，配置文件，使用的设备，调用的其它应用程序等，在strace下，程序干了什么东东一目了然。ps #显示当前系统进程信息ps –ef #显示系统所有进程信息kill -9 500 #将进程编号为500的程序干掉killall -9 netscape #将所有名字为netscape的程序杀死，kill不是万能的，对僵死的程序则无效。top #显示系统进程的活动情况，按占CPU资源百分比来分free #显示系统内存及swap使用情况time program #在program程序结束后，将计算出program运行所使用的时间 123456789101112131415161718192021222324chroot . #将根目录切换至当前目录,调试新系统时使用chroot /tomlinux #将根目录切换至/tomlinux目录chroot /tomlinux sbin/init #将根目录切换至/tomlinux并执行sbin/initadduser id #增加一个叫id的用户userdel id #增除叫id的用户userlist #显示已登陆的用户列表passwd id #修改用户id的密码passwd -d root #将root用户的密码删除chown id /work #指定/work目录为id用户所拥有``` ``` bashifconfig eth0 192.168.1.1 netmask 255.255.255.0 #设置网卡1的地址192.168.1.1，掩码为255.255.255.0，不写netmask参数则默认为255.255.255.0ifconfig eth0:1 192.168.1.2 #捆绑网卡1的第二个地址为192.168.1.2ifconfig eth0:x 192.168.1.x #捆绑网卡1的第二个地址为192.168.1.xifconfig down eth1 #关闭第二块网卡，使其停止工作hostname -F tomlinux.com #将主机名设置为tomlinux.comroute #显示当前路由设置情况route add default gw 192.168.1.1 metric 1 #设置192.168.1.1为默认的路由route del default #将默认的路由删除dhcp #启动dhcp服务dhclient #启动dhcp终端并自动获取IP地址ping 163.com #测试与163.com的连接ping 202.96.128.68 #测试与IP 202。96.128.68的连接 1234567probe rtl8139 #检查驱动程序rtl8139.o是否正常工作lsmod #显示已装载的驱动程序insmod rtl8139.o #装载驱动程序rtl8139.oinsmod sb.o io=0x280 irq=7 dma=3 dma16=7 mpu_io=330 #装载驱动程序并设置相关的irq,dma参数rmmod rtl8139 #删除名为rtl8139的驱动模块gpm -k #停止字符状态下的mouse服务gpm -t ps2 #在字符状态下以ps2类型启动mouse的服务 123telnet 192.168.1.1 #登陆IP为192.168.1.1的telnet服务器telnet iserver.com #登陆域名为iserver.com的telnet服务器ftp 192.168.1.1 或 ftp iserver.com #登陆到ftp服务 * Linux开发中的常用命令(cygwin环境也同样适用)","tags":[]}]